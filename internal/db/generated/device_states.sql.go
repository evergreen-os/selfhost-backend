// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: device_states.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteDeviceState = `-- name: DeleteDeviceState :exec
DELETE FROM device_states
WHERE device_id = $1
`

func (q *Queries) DeleteDeviceState(ctx context.Context, deviceID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDeviceState, deviceID)
	return err
}

const getDeviceState = `-- name: GetDeviceState :one
SELECT device_id, active_policy_id, policy_applied_at, installed_apps, update_status, health_metrics, last_error, reported_at, updated_at FROM device_states
WHERE device_id = $1
`

func (q *Queries) GetDeviceState(ctx context.Context, deviceID pgtype.UUID) (DeviceState, error) {
	row := q.db.QueryRow(ctx, getDeviceState, deviceID)
	var i DeviceState
	err := row.Scan(
		&i.DeviceID,
		&i.ActivePolicyID,
		&i.PolicyAppliedAt,
		&i.InstalledApps,
		&i.UpdateStatus,
		&i.HealthMetrics,
		&i.LastError,
		&i.ReportedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStaleDeviceStates = `-- name: GetStaleDeviceStates :many
SELECT ds.device_id, ds.active_policy_id, ds.policy_applied_at, ds.installed_apps, ds.update_status, ds.health_metrics, ds.last_error, ds.reported_at, ds.updated_at FROM device_states ds
WHERE ds.reported_at < $1
ORDER BY ds.reported_at ASC
LIMIT $2
`

type GetStaleDeviceStatesParams struct {
	ReportedAt pgtype.Timestamptz `json:"reported_at"`
	Limit      int32              `json:"limit"`
}

func (q *Queries) GetStaleDeviceStates(ctx context.Context, arg GetStaleDeviceStatesParams) ([]DeviceState, error) {
	rows, err := q.db.Query(ctx, getStaleDeviceStates, arg.ReportedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceState{}
	for rows.Next() {
		var i DeviceState
		if err := rows.Scan(
			&i.DeviceID,
			&i.ActivePolicyID,
			&i.PolicyAppliedAt,
			&i.InstalledApps,
			&i.UpdateStatus,
			&i.HealthMetrics,
			&i.LastError,
			&i.ReportedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceStatesByTenant = `-- name: ListDeviceStatesByTenant :many
SELECT ds.device_id, ds.active_policy_id, ds.policy_applied_at, ds.installed_apps, ds.update_status, ds.health_metrics, ds.last_error, ds.reported_at, ds.updated_at FROM device_states ds
JOIN devices d ON ds.device_id = d.id
WHERE d.tenant_id = $1
ORDER BY ds.reported_at DESC
LIMIT $2 OFFSET $3
`

type ListDeviceStatesByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListDeviceStatesByTenant(ctx context.Context, arg ListDeviceStatesByTenantParams) ([]DeviceState, error) {
	rows, err := q.db.Query(ctx, listDeviceStatesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceState{}
	for rows.Next() {
		var i DeviceState
		if err := rows.Scan(
			&i.DeviceID,
			&i.ActivePolicyID,
			&i.PolicyAppliedAt,
			&i.InstalledApps,
			&i.UpdateStatus,
			&i.HealthMetrics,
			&i.LastError,
			&i.ReportedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDeviceState = `-- name: UpsertDeviceState :one
INSERT INTO device_states (
    device_id,
    active_policy_id,
    policy_applied_at,
    installed_apps,
    update_status,
    health_metrics,
    last_error,
    reported_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) ON CONFLICT (device_id) DO UPDATE SET
    active_policy_id = EXCLUDED.active_policy_id,
    policy_applied_at = EXCLUDED.policy_applied_at,
    installed_apps = EXCLUDED.installed_apps,
    update_status = EXCLUDED.update_status,
    health_metrics = EXCLUDED.health_metrics,
    last_error = EXCLUDED.last_error,
    reported_at = EXCLUDED.reported_at,
    updated_at = NOW()
RETURNING device_id, active_policy_id, policy_applied_at, installed_apps, update_status, health_metrics, last_error, reported_at, updated_at
`

type UpsertDeviceStateParams struct {
	DeviceID        pgtype.UUID        `json:"device_id"`
	ActivePolicyID  *string            `json:"active_policy_id"`
	PolicyAppliedAt pgtype.Timestamptz `json:"policy_applied_at"`
	InstalledApps   []byte             `json:"installed_apps"`
	UpdateStatus    []byte             `json:"update_status"`
	HealthMetrics   []byte             `json:"health_metrics"`
	LastError       *string            `json:"last_error"`
	ReportedAt      pgtype.Timestamptz `json:"reported_at"`
}

func (q *Queries) UpsertDeviceState(ctx context.Context, arg UpsertDeviceStateParams) (DeviceState, error) {
	row := q.db.QueryRow(ctx, upsertDeviceState,
		arg.DeviceID,
		arg.ActivePolicyID,
		arg.PolicyAppliedAt,
		arg.InstalledApps,
		arg.UpdateStatus,
		arg.HealthMetrics,
		arg.LastError,
		arg.ReportedAt,
	)
	var i DeviceState
	err := row.Scan(
		&i.DeviceID,
		&i.ActivePolicyID,
		&i.PolicyAppliedAt,
		&i.InstalledApps,
		&i.UpdateStatus,
		&i.HealthMetrics,
		&i.LastError,
		&i.ReportedAt,
		&i.UpdatedAt,
	)
	return i, err
}
